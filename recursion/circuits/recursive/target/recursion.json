{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":14081661684729575307,"abi":{"parameters":[{"name":"verification_key","type":{"kind":"array","length":114,"type":{"kind":"field"}},"visibility":"private"},{"name":"proof","type":{"kind":"array","length":93,"type":{"kind":"field"}},"visibility":"private"},{"name":"public_inputs","type":{"kind":"array","length":1,"type":{"kind":"field"}},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"nd3NahxHFIbhe5m1Fn2qz6kf30oIQbblIDCyseRAML73jJNokVg2PLVTS/3N5kEw83Yhfbm8vXv9+fff7h/efXi8vPrly+X9hze3T/cfHq5XXy7n3996/Hj78O3q8en209PlVWTeXO4e3l6/mv3rzeXd/fu7y6scX2++v7Ud6/ne9u2Of29u6+uvN5d86dVbPC9a/ufVr4PSQdfB0MHUwdJBHLwIXjRenLxg7mDvYPBg8WDyYPPG5o3NG5s3Nm9s3ti8sXlj88bmjc1PNj/Z/GTzk81PNj/Z/GTzk81PNj/ZPNk82TzZPNk82TzZPNk82TzZPNm82LzYvNi82Lz87RubF5sXmxebF5t3Nu9s3tm8s3ln8+7v2dm8s3ln887mg80Hmw82H2w+2Hyw+fAPamw+2Hyw+WTzyeaTzSebTzafbD7ZfPqnczafbL7YfLH5YvPF5ovNF5svNl9svjzJbDQZjzKHV5nDs8zhXebwMHN4mTk8zRzeZg6PM4fr7yQ519+IchtVbiPLbXS5jTC3UeY20py3ufA4F22jyLq+97nwQBde6MITXXijC4904ZUuPNOFd7o4N4K863uqC2914bEuvNaF57rwXhce7MKLXXiyi9x4HuP6Xu3Cs114twsPd+HlLjzdhbe78HgXXu/C8114vwsPeOEFLzzhhTe88IgXXvHCM154xwsPedE3nsa6vre88JgXXvPCc154zwsPeuFFLzzphTe9GBsP413fs1541wsPe+FlLzzthbe98LgXXvfC817MjbMYru+FLzzxhTe+8MgXXvnCM1945wsPfeGlL9bGUZyNszh+GMdbX/PW17z1NW99zVtf89bXvPU1b33NW1+LjaNYru+tr3nra976mre+5q2veetr3vraxjm8jYN4OyfxXH/jLN7GYbyN03gbx/E2zuNtHMjz1te89TVvfe3cOIj5sn6N58k4v5ukT8on3SfDJ9Mniyc/aH0/nYRPmk9cP10/XT9dP10/XT9dv1y/XL9cv1y/XL9cv1y/XL9cv1y/u353/e763fW763fX767fXb+7fnf94frD9YfrD9cfrj9cf7j+cP3h+sP1p+tP15+uP11/uv50/en60/Wn60/XX66/XH+5/nL95frL9ZfrL9dfrr9Y/zwOn4RPmk9On6RPyifdJ8Mn0yeuH64frh+uH64frh+uH64frh+uH67fXL+5fnP95vrN9ZvrN9f/Qeubz39S4Pqb/t1k+uRF/esTtufJmf+fvNz6fj4JnzSfnD5Jn5RPuk+GT6ZPXD9dP10/XT9dP10/XT9dP10/XT9dv1y/XL9cv1y/XL9cv1y/XL9cv1y/u353/e763fW763fX767fXb+7fnf94frD9YfrD9cfrj9cf7j+cP3h+sP1p+tP15+uP11/uv50/en60/Wn60/XX66/XH+5/nL95frL9ZfrL9dfrr9YP4/DJ+GT5pPTJ+mT8kn3yfDJ9Inrh+uH64frh+uH64frh+uH64frh+s312+u31y/uX5z/eb6zfWb6zfX99aX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731pbe+9NaX3vrSW19660tvfemtL731lbe+8tZX3vrKW1956ytvfeWtr7z1lbe+8tZX3vrKW1956ytvfeWtr7z1lbe+8tZX3vrKW1956ytvfeWtr7z1lbe+8tZX3vrKW1956ytvfeWtr7z1lbe+8tZX3vrKW1956yttfdeLP24/3d++fn/3eB18+9nnhzfP/3bqevn058d/fnK99y8=","file_map":{"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::EmbeddedCurvePoint;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<N>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"47":{"source":"use dep::std;\n\nfn main(\n    verification_key : [Field; 114], \n    proof : [Field; 93], \n    public_inputs : [Field; 1], \n) {\n    let key_hash = std::hash::pedersen_hash(verification_key);\n    std::verify_proof(\n        verification_key.as_slice(), \n        proof.as_slice(), \n        public_inputs.as_slice(), \n        key_hash,\n    );\n}","path":"/Users/catmcgee/Documents/Work/noir-vsummit/recursion/recursive/src/main.nr"}},"names":["main"]}